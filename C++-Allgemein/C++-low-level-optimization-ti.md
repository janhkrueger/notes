# C++ low-level optimization tips

Created: 2021-10-25 09:35:57 +0200

Modified: 2021-10-25 16:42:54 +0200

---


Game Development Stack Exchange is a question and answer site for professional and independent game developers. It's 100% free, no registration required.

[**C++ low-level optimization tips**](https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips)

<table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th><p>Assuming you already have the best-choice algorithm, what low-level solutions can you offer for squeezing the last few drops of sweet sweet frame rate out of C++ code?</p><p>It goes without saying that these tips only apply to that critical code section that you've already highlighted in your profiler, but they should be low-level non-structural improvements. I've seeded an example.</p><p><a href="https://gamedev.stackexchange.com/questions/tagged/c++">c++</a> <a href="https://gamedev.stackexchange.com/questions/tagged/optimization">optimization</a></p><p></p></th></tr></thead><tbody><tr class="odd"><td><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>What makes this a game development question and not a general programming question like these: <a href="http://stackoverflow.com/search?q=c+++optimization">stackoverflow.com/search?q=c%2B%2B+optimization</a>–<a href="https://gamedev.stackexchange.com/users/318/danny-varod">Danny Varod</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment641_853">Jul 21 '10 at 19:01</a></th></tr></thead><tbody><tr class="odd"><td>@Danny - This probably could be a general programming question. It is also certainly a question related to games programming. I think it's a viable question on both sites. –<a href="https://gamedev.stackexchange.com/users/321/smashery">Smashery</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment704_853">Jul 21 '10 at 23:03</a></td></tr><tr class="even"><td>@Smashery The only difference between the two is that game programming can require specific graphics engine level optimizations or shader coder optimizations, the C++ part is the same. –<a href="https://gamedev.stackexchange.com/users/318/danny-varod">Danny Varod</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment982_853">Jul 23 '10 at 9:47</a></td></tr><tr class="odd"><td>@Danny - True, some questions will be "more" relevant on one site or the other; but I wouldn't want to turn away any relevant questions just because they could also be asked on another site. –<a href="https://gamedev.stackexchange.com/users/321/smashery">Smashery</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment1171_853">Jul 26 '10 at 0:43</a></td></tr></tbody></table><p></p></td></tr></tbody></table>





<table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th><p><strong>Optimise your data layout!</strong>(This applies to more languages than just C++)</p><p>You can go pretty deep making this specifically tuned for your data, your processor, handling multi-core nicely, etc. But the basic concept is this:</p><p>When you are processing things in a tight loop, you want to make the data for each iteration as small as possible, and as close together as possible in memory. That means the ideal is an array or vector of objects (not pointers) that contain only the data necessary for the calculation.</p><p>This way, when the CPU fetches the data for the first iteration of your loop, the next several iterations worth of data will get loaded into the cache with it.</p><p>Really the CPU is fast and the compiler is good. There's not really much you can do with using fewer and faster instructions. <a href="http://supercomputingblog.com/optimization/taking-advantage-of-cache-coherence-in-your-programs/">Cache coherence</a>is where it's at (that's a random article I Googled - it contains a good example of getting cache coherency for an algorithm that doesn't simply run through data linearly).</p></th></tr></thead><tbody><tr class="odd"><td><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>It's worth trying out the C example in the linked Cache coherence page. When I first found out about this I was shocked as to how much of a difference it makes. –<a href="https://gamedev.stackexchange.com/users/713/neel">Neel</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment806_870">Jul 22 '10 at 11:48</a></th></tr></thead><tbody><tr class="odd"><td>See also the excellent Pitfalls of Object Oriented Programming presentation (Sony R&amp;D) ( <a href="http://research.scee.net/files/presentations/gcapaustralia09/Pitfalls_of_Object_Oriented_Programming_GCAP_09.pdf">research.scee.net/files/presentations/gcapaustralia09/…</a>) -- and the cranky but fascinating CellPerformance articles by Mike Acton ( <a href="http://cellperformance.beyond3d.com/articles/index.html">cellperformance.beyond3d.com/articles/index.html</a>). Noel Llopis's Games from Within blog also touches on this subject frequently ( <a href="http://gamesfromwithin.com/">gamesfromwithin.com</a>). I cannot recommend the Pitfalls slides enough... –<a href="https://gamedev.stackexchange.com/users/1134/leander">leander</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment3147_870">Aug 24 '10 at 2:24</a></td></tr><tr class="even"><td>I'd just warn about <em>"make the data for each iteration as small as possible, and as close together as possible in memory"</em>. Accessing non-aligned data can make things slower; in which case padding will give better performances. The <em>order</em>of data is important too, as well ordered data can lead to less padding. <a href="http://aristeia.com/">Scott Mayers</a>can explain this better than I can though :) –<a href="https://gamedev.stackexchange.com/users/8921/jonathan-connell">Jonathan Connell</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment23481_870">Aug 4 '11 at 9:45</a></td></tr><tr class="odd"><td>+1 to the Sony presentation. I read that one before and it really gives sense at how to optimize data at the platform level, with consideration on splitting data into chunks and aligning it properly. –<a href="https://gamedev.stackexchange.com/users/9789/chrisc">ChrisC</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment28060_870">Oct 3 '11 at 19:11</a></td></tr></tbody></table></td></tr></tbody></table>

<table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th><p>A very, very low-level tip, but one that can come in handy:</p><p>Most compilers support some form of explicit conditional hinting. GCC has a function called __builtin_expect which lets you inform the compiler what the value of a result probably is. GCC can use that data to optimize conditionals to perform as quickly as possible in the expected case, with slightly slower execution in the unexpected case.</p><p>if(__builtin_expect(entity-&gt;extremely_unlikely_flag, 0)) {</p><p>// code that is rarely run</p><p>}</p><p>I've seen a 10-20% speedup with proper use of this.</p><p></p></th></tr></thead><tbody><tr class="odd"><td><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>I'd vote-up twice if I could. –<a href="https://gamedev.stackexchange.com/users/259/tenpn">tenpn</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment629_871">Jul 21 '10 at 16:53</a></th></tr></thead><tbody><tr class="odd"><td>+1, The Linux kernel uses this <em>extensively</em>for microoptimizations in scheduler code, and it makes a significant difference in certain code paths. –<a href="https://gamedev.stackexchange.com/users/613/greyfade">greyfade</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment755_871">Jul 22 '10 at 4:53</a></td></tr><tr class="even"><td>Unfortunately, there seems to be no good equivalent in Visual Studio. <a href="http://stackoverflow.com/questions/1440570/likely-unlikely-equivalent-for-msvc">stackoverflow.com/questions/1440570/…</a>–<a href="https://gamedev.stackexchange.com/users/233/mmyers">mmyers</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment828_871">Jul 22 '10 at 14:41</a></td></tr></tbody></table></td></tr></tbody></table>

<table><colgroup><col style="width: 9%" /><col style="width: 90%" /></colgroup><thead><tr class="header"><th></th><th><p>The first thing you need to understand is the hardware you're running on. How does it handle branching? What about caching? Does it have a SIMD instruction set? How many processors can it use? Does it have to share processor time with anything else?</p><p>You may solve the same problem in very different ways - even your choice of algorithm should be dependent on the hardware. In some cases O(N) can run slower than O(NlogN) (depending on implementation).</p><p>As a crude overview of optimisation, the first thing I would do is look at exactly what problems and what data you are trying to solve for. Then optimise for that. If you want extreme performance then forget about generic solutions - you can special case everything that doesn't match your most used case.</p><p>Then profile. Profile, profile, profile. Look at memory usage, look at branching penalties, Look at function call overhead, look at pipeline utilisation. Work out what is slowing down your code. It's probably data access (I wrote an article called "The Latency Elephant" about the overhead of data access - google it. I can't post 2 links here as I don't have enough "reputation"), so closely examine that and then optimise your data layout (<a href="http://research.scee.net/files/presentations/gcapaustralia09/Pitfalls_of_Object_Oriented_Programming_GCAP_09.pdf">nice big flat homogeneous arrays are awesome</a>) and data access (prefetch where possible).</p><p>Once you've minimised the overhead of the memory subsystem, try and determine if instructions are now the bottleneck (hopefully they are), then look at SIMD implementations of your algorithm - Structure-of-Arrays (SoA) implementations can be very data and instruction cache efficient. If SIMD isn't a good match for your problem then intrinsics and assembler level coding may be needed.</p><p>If you still need more speed then go parallel. If you have the benefit of running on a PS3 then the SPUs are your friends. Use them, love them. If you've already written a SIMD solution then you'll get a massive benefit moving to SPU.</p><p>And then, profile some more. Test in game scenarios - is this code still the bottleneck? Can you change the way this code is used at a higher level to minimise its usage (actually, this should be your first step)? Can you defer calculations over multiple frames?</p><p>Whatever platform you're on, learn as much as you can about the hardware and the profilers available. Don't assume that you know what the bottleneck is - find it with your profiler. And make sure you have a heuristic to determine if you have actually made your game go faster.</p><p>And then profile it again.</p><p></p></th></tr></thead><tbody></tbody></table>

<table><colgroup><col style="width: 8%" /><col style="width: 91%" /></colgroup><thead><tr class="header"><th></th><th><p>First step: Think carefully about your data in relation to your algorithms. O(log n) is not always faster than O(n). Simple example: A hash table with only a few keys is often better replaced with a linear search.</p><p>Second step: Look at the assembly generated. C++ brings a lot of implicit code generation to the table. Sometimes, it sneaks up on you without you knowing.</p><p>But assuming it's really pedal-to-the-metal time: Profile. Seriously. Randomly applying "performance tricks" is about as likely to hurt as it is to help.</p><p>Then, everything depends on what your bottlenecks are.</p><p>data cache misses =&gt; optimize your data layout. Here's a good starting point: <a href="http://gamesfromwithin.com/data-oriented-design">http://gamesfromwithin.com/data-oriented-design</a></p><p>code cache misses =&gt; Look at virtual function calls, excessive callstack depth, etc. A common cause for bad performance is the erroneous belief that base classes <em>must</em>be virtual.</p><p>Other common C++ performance sinks:</p><ul class="incremental"><li><p>Excessive allocation/deallocation. If it's performance critical, don't call into the runtime. Ever.</p></li><li><p>Copy construction. Avoid wherever you can. If it can be a const reference, make it one.</p></li></ul><p>All of the above are immediately obvious when you look at the assembly, so see above ;)</p><p></p></th></tr></thead><tbody></tbody></table>

<table><colgroup><col style="width: 9%" /><col style="width: 90%" /></colgroup><thead><tr class="header"><th></th><th><p><strong>Remove unnecessary branches</strong></p><p>On some platforms and with some compilers, branches can throw away your whole pipeline, so even insignificant if() blocks can be expensive.</p><p>The PowerPC architecture (PS3/x360) offers the floating-point select instruction, fsel. This can be used in the place of a branch if the blocks are simple assignments:</p><p>float result = 0;</p><p>if (foo &gt; bar) { result = 2.0f; }</p><p>else { result = 1.0f; }</p><p>Becomes:</p><p>float result = fsel(foo-bar, 2.0f, 1.0f);</p><p>When the first parameter is greater than or equal to 0, the second paramter is returned, else the third.</p><p>The price of losing the branch is that both the if{} and the else{} block will be executed, so if one is an expensive operation or dereferences a NULL pointer this optimisation is not suitable.</p><p>Sometimes your compiler has already done this work, so check your assembly first.</p><p>Here's more information on branching and fsel:</p><p><a href="http://assemblyrequired.crashworks.org/tag/intrinsics/">http://assemblyrequired.crashworks.org/tag/intrinsics/</a></p><p></p></th></tr></thead><tbody><tr class="odd"><td></td><td><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>float result = (foo &gt; bar) ? 2.f : 1.f –<a href="https://gamedev.stackexchange.com/users/662/knight666">knight666</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment807_855">Jul 22 '10 at 11:52</a></th></tr></thead><tbody><tr class="odd"><td>@knight666: That will still produce a branch anywhere that a longhand "if" would've done. I say it like that because on ARM, at least, small sequences like that can be implemented with conditional instructions which don;t require branching. –<a href="https://gamedev.stackexchange.com/users/754/chrisbtoo">chrisbtoo</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment816_855">Jul 22 '10 at 13:40</a></td></tr><tr class="even"><td>@knight666 if you're lucky the compiler can turn that into an fsel, but it's not certain. FWIW, I would normally write that snippet with a tertiary operator, and then later on optimise to fsel if the profiler agreed. –<a href="https://gamedev.stackexchange.com/users/259/tenpn">tenpn</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment817_855">Jul 22 '10 at 13:49</a></td></tr><tr class="odd"><td>On IA32 you've got CMOVcc instead. –<a href="https://gamedev.stackexchange.com/users/1143/skizz">Skizz</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment3133_855">Aug 23 '10 at 23:22</a></td></tr><tr class="even"><td>See also <a href="http://www.blueraja.com/blog/285/branchless-conditionals-compiler-optimization-technique">blueraja.com/blog/285/…</a>(note that in this case, if the compiler is any good, it should be able to optimize this itself, so it's not something you normally have to worry about) –<a href="https://gamedev.stackexchange.com/users/2061/blueraja-danny-pflughoeft">BlueRaja - Danny Pflughoeft</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment21504_855">Jul 10 '11 at 8:26</a></td></tr></tbody></table></td></tr></tbody></table>

<table><colgroup><col style="width: 8%" /><col style="width: 91%" /></colgroup><thead><tr class="header"><th></th><th><p>Avoid memory accesses and especially random ones at all costs.</p><p>That's the single most important thing to optimize for on modern CPUs. You can do a shitload of arithmetic and even a lot of wrong predicted branches in the time you wait for data from RAM.</p><p>You can also read this rule the other way around: Do as much calculations as possible between memory accesses.</p><p></p></th></tr></thead><tbody></tbody></table>

<table><colgroup><col style="width: 8%" /><col style="width: 91%" /></colgroup><thead><tr class="header"><th></th><th><p><strong>Use Compiler Intrinsics.</strong></p><p>Ensure that the compiler is generating the most efficient assembly for certain operations by using intrinsics - constructs that look like function calls that the compiler turns into optimized assembly:</p><p><a href="http://msdn.microsoft.com/en-us/library/26td21ds(VS.80).aspx">Here's a reference for Visual Studio</a>, and <a href="http://gcc.gnu.org/onlinedocs/gcc-3.4.1/gcc/X86-Built-in-Functions.html">here's one for GCC</a></p><p></p></th></tr></thead><tbody></tbody></table>

<table><colgroup><col style="width: 8%" /><col style="width: 91%" /></colgroup><thead><tr class="header"><th></th><th><p><strong>Remove unnecessary virtual function calls</strong></p><p>The dispatch of a virtual function can be very slow. <a href="http://thetweaker.wordpress.com/2010/06/03/on-_purecall-and-the-overheads-of-virtual-functions/">This</a>article gives a good explaination of why. If possible, for functions that are called many many many times per frame, avoid them.</p><p>You can do this in a couple of ways. Sometimes you can just rewrite the classes to not need inheritence - maybe it turns out that MachineGun is the only subclass of Weapon, and you can amalgamate them.</p><p>You can use templates to replace run-time polymorphism with compile-time polymorphism. This only works if you know the subtype of your objects at runtime, and can be a major rewrite.</p><p></p></th></tr></thead><tbody></tbody></table>

<table><colgroup><col style="width: 8%" /><col style="width: 91%" /></colgroup><thead><tr class="header"><th></th><th><p>Use SIMD (by SSE), if you don't do already. Gamasutra has a nice <a href="http://www.gamasutra.com/view/feature/4248/designing_fast_crossplatform_simd_.php">article on this</a>. You can download the source code from the presented library at the end of the article.</p><p></p></th></tr></thead><tbody></tbody></table>

<table><colgroup><col style="width: 8%" /><col style="width: 91%" /></colgroup><thead><tr class="header"><th></th><th><p>My basic principle is: <em>don't do anything that's not necessary</em>.</p><p>If you've found that a particular function is a bottleneck, you could optimize the function -- or you could try to keep it from being called in the first place.</p><p>This does not necessarily mean you're using a bad algorithm. It might mean that you are running calculations every frame that could be cached for a short while (or entirely precalculated), for example.</p><p>I always try this approach before any attempts at really low-level optimization.</p><p></p></th></tr></thead><tbody><tr class="odd"><td></td><td><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>This question assumes you've already done all the structural stuff you can. –<a href="https://gamedev.stackexchange.com/users/259/tenpn">tenpn</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment626_872">Jul 21 '10 at 16:27</a></th></tr></thead><tbody><tr class="odd"><td>It does. But often you assume you have, and you haven't. So really, every time an expensive function needs to be optimized, ask yourself if you need to call that function. –<a href="https://gamedev.stackexchange.com/users/181/rachel-blum">Rachel Blum</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment685_872">Jul 21 '10 at 21:22</a></td></tr><tr class="even"><td>...but sometimes it can actually be quicker to do the calculation even if you're going to throw away the result afterwards, rather than branch. –<a href="https://gamedev.stackexchange.com/users/259/tenpn">tenpn</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment11874_872">Feb 24 '11 at 21:58</a></td></tr></tbody></table></td></tr></tbody></table>

<table><colgroup><col style="width: 8%" /><col style="width: 91%" /></colgroup><thead><tr class="header"><th></th><th><p>Minimize dependency chains to make better use of the CPU pipleline.</p><p>In simple cases the compiler may do this for you if you enable loop unrolling. However it often won't do it, especially when there's floats involved as reordering the expressions changes the result.</p><p>Example:</p><p>float *data = ...;</p><p>int length = ...;</p><p></p><p>// Slow version</p><p>float total = 0.0f;</p><p>int i;</p><p>for (i=0; i &lt; length; i++)</p><p>{</p><p>total += data[i]</p><p>}</p><p></p><p>// Fast version</p><p>float total1, total2, total3, total4;</p><p>for (i=0; i &lt; length-3; i += 4)</p><p>{</p><p>total1 += data[i];</p><p>total2 += data[i+1];</p><p>total3 += data[i+2];</p><p>total4 += data[i+3];</p><p>}</p><p>for (; i &lt; length; i++)</p><p>{</p><p>total += data[i]</p><p>}</p><p>total += (total1 + total2) + (total3 + total4);</p><p></p></th></tr></thead><tbody></tbody></table>

<table><colgroup><col style="width: 9%" /><col style="width: 90%" /></colgroup><thead><tr class="header"><th></th><th><p>Don't overlook your compiler -- if you are using gcc on Intel, you could easily get a performance gain by switching to the Intel C/C++ Compiler, for example. If you are targeting an ARM platform, check out ARM's commercial compiler. If you are on the iPhone, Apple just allowed Clang to be used starting with the iOS 4.0 SDK.</p><p>One issue that you will probably come into with optimization, especially on the x86, is that a lot of intuitive things end up working against you on modern CPU implementations. Unfortunately for most of us, the ability to out optimize the compiler is long gone. The compiler can schedule instructions in the stream based on it's own internal knowledge of the CPU. In addition, the CPU can also re-schedule instructions based on it's own needs. Even if you think of an optimal way to arrange a method, chances are the compiler or CPU has already come up with that on it's own and has already performed that optimization.</p><p>My best advice would be to ignore the low-level optimizations and focus on the higher level ones. The compiler and CPU can't change your algorithm from an O(n^2) to an O(1) algorithm, no matter how good they get. That's going to require you to look at exactly what you are trying to do and find a better way to do it. Let the compiler and CPU worry about the low level and you focus on the mid to high levels.</p></th></tr></thead><tbody><tr class="odd"><td></td><td><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>I see what you're saying, but there comes a point when you've reached O(logN) and you're not going to get any more out of structural changes, where the low-level optimisations can come into play and gain you that extra half a millisecond. –<a href="https://gamedev.stackexchange.com/users/259/tenpn">tenpn</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment616_864">Jul 21 '10 at 14:34</a></th></tr></thead><tbody><tr class="odd"><td>See my answer re: O(log n). Also, if you look for half a millisecond, you might need to look at the higher level. That's 3% of your frame time! –<a href="https://gamedev.stackexchange.com/users/181/rachel-blum">Rachel Blum</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment688_864">Jul 21 '10 at 21:25</a></td></tr></tbody></table></td></tr></tbody></table>

<table><colgroup><col style="width: 7%" /><col style="width: 92%" /></colgroup><thead><tr class="header"><th></th><th><p>The <strong>restrict</strong>keyword is potentially handy, especially in cases where you need to manipulate objects with pointers. It allows the compiler to assume the pointed-to object is not going to get modified in any other way which in turn allows it to perform more aggressive optimisation such as keeping parts of the object in registers or reordering reads and writes more effectively.</p><p>One good thing about the keyword is that it's a hint which you can apply once and see benefits from without rearranging your algorithm. The bad side is that if you use it in the wrong place, you might see data corruption. But usually it's quite easy to spot where it's legitimate to use it - it's one of the few examples where the programmer can reasonably be expected to know more than the compiler can safely assume, which is why the keyword has been introduced.</p><p>Technically 'restrict' doesn't exist in standard C++, but platform-specific equivalents are available for most C++ compilers, so it's worth considering.</p><p>See also: <a href="http://cellperformance.beyond3d.com/articles/2006/05/demystifying-the-restrict-keyword.html">http://cellperformance.beyond3d.com/articles/2006/05/demystifying-the-restrict-keyword.html</a></p><p></p></th></tr></thead><tbody></tbody></table>

<table><colgroup><col style="width: 10%" /><col style="width: 89%" /></colgroup><thead><tr class="header"><th></th><th><p><strong>Const everything!</strong></p><p>The more information you give the compiler about the data the better the optimizations are (at least in my experience).</p><p>void foo(Bar * x) {...;}</p><p>becomes;</p><p>void foo(const Bar * const x) {...;}</p><p>The compiler now knows that the pointer x is not going to change and that the data it is pointing to will not change either.</p><p>The other added benefit is that you can reduce the number of accidental bugs, stopping yourself (or others) modifying things that they shouldn't.</p></th></tr></thead><tbody><tr class="odd"><td></td><td><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>And your code buddy will love you! –<a href="https://gamedev.stackexchange.com/users/259/tenpn">tenpn</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment1012_1380">Jul 23 '10 at 14:13</a></th></tr></thead><tbody><tr class="odd"><td>const does not improve compiler optimizations. True the compiler can generate better code if it knows a variable won't change, but const does not provide a strong enough guarantee. –<a href="https://gamedev.stackexchange.com/users/370/deft-code">deft_code</a> <a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment1018_1380">Jul 23 '10 at 15:04</a></td></tr><tr class="even"><td>Nope. 'restrict' is far more useful than 'const'. See <a href="http://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/3118#3118">gamedev.stackexchange.com/questions/853/…</a>–<a href="https://gamedev.stackexchange.com/users/831/justicle">Justicle</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment4234_1380">Sep 14 '10 at 22:19</a></td></tr><tr class="odd"><td>+1 ppl saying const cant help are wrong... <a href="http://www.infoq.com/presentations/kixeye-scalability">infoq.com/presentations/kixeye-scalability</a>–<a href="https://gamedev.stackexchange.com/users/50001/nosenseetal">NoSenseEtAl</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment145369_1380">Aug 1 '14 at 0:21</a></td></tr></tbody></table></td></tr></tbody></table>

<table><colgroup><col style="width: 9%" /><col style="width: 90%" /></colgroup><thead><tr class="header"><th></th><th><p>Most often, the best way to gain performance is to change your algorithm. The less general the implementation the closer you can get to the metal.</p><p>Assuming that has been done....</p><p>If it's really critical code indeed, try to avoid memory reads, try to avoid calculating stuff that can be precalculated (though no lookup tables as they violate rule number 1). Know what your algorithm does and write it in a way that the compiler knows it too. Check the assembly to be sure it does.</p><p>Avoid cache misses. Batch process as much as you can. Avoid virtual functions and other indirections.</p><p>Ultimately, measure everything. The rules change all the time. What used to speed up code 3 years ago now slows it down. A nice example is 'use double math functions instead of float versions'. I wouldn't have realized that one if I hadn't read it.</p><p>I forgot - don't have default constructors intialize your variables, or if you insist, at least also create constructors that don't. Be aware of the things that don't show up in the profiles. When you lose one unnecessary cycle per line of code nothing will show up in your profiler, but you'll lose a whole lot of cycles overall. Again, know what your code is doing. Make your core function lean instead of foolproof. Foolproof versions can be called if needed, but are not always needed. Versatility comes at a price - performance being one.</p><p>Edited to explain why no default initialization: A lot of code says: Vector3 bla; bla = DoSomething();</p><p>The intialization in the constructor is wasted time. Also, in this case the wasted time is small (probably clearing the vector), however if your programmers do this habitually it adds up. Also, a lot of function create a temporary (think overloaded operators), that gets initialized to zero and assigned after straight away. Hidden lost cycles that are too small to see a spike in your profiler, but bleed cycles all over your code base. Also, some people do a lot more in constructors (which is obviously a no-no). I've seen multi-millisecond gains from an unused variable where the constructor happened to be a bit on the heavy side. As soon as the constructor causes side effects the compiler won't be able to optmize it out, so unless you never use above code, I prefer either a non-initializing constructor, or, as I said, a version of the constructor that doesn't initialize.</p><p>Vector3 bla(noInit); bla = doSomething();</p><p></p></th></tr></thead><tbody><tr class="odd"><td></td><td><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>/Don't/ initialise your members in constructors? How does that help? –<a href="https://gamedev.stackexchange.com/users/259/tenpn">tenpn</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment1085_1438">Jul 24 '10 at 9:39</a></th></tr></thead><tbody><tr class="odd"><td>const Vector3 = doSomething()? Then the return-value optimisation can kick in and probably elise an assignment or two. –<a href="https://gamedev.stackexchange.com/users/259/tenpn">tenpn</a> <a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment3121_1438">Aug 23 '10 at 15:22</a></td></tr></tbody></table></td></tr></tbody></table>

<table><colgroup><col style="width: 10%" /><col style="width: 89%" /></colgroup><thead><tr class="header"><th></th><th><p><strong>Reduce boolean expression evaluation</strong></p><p>This one is really desperate, as it's a very subtle but dangerous change to your code. However if you have a conditional that is evaluated an inordinate number of times, you can reduce the overhead of boolean evaluation by using bitwise operators instead. So:</p><p>if ((foo &amp;&amp; bar) || blah) { ... }</p><p>Becomes:</p><p>if ((foo &amp; bar) | blah) { ... }</p><p>Using integer arithmetic instead. If your foos and bars are constants or evaluated before the if(), this could be faster than the normal boolean version.</p><p>As a bonus the arithmetic version has less branches than the regular boolean version. Which is another way to <a href="http://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/855#855">optimize</a>.</p><p>The big downside is that you lose lazy evaluation - the whole block is evaluated, so you can't do foo != NULL &amp; foo-&gt;dereference(). Because of this, it's arguable that this is hard to maintain, and so the trade-off may be too great.</p><p></p></th></tr></thead><tbody><tr class="odd"><td></td><td><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>That's a pretty egregious trade-off for the sake of performance, mainly because it's not immediately obvious that it was intended. –<a href="https://gamedev.stackexchange.com/users/263/bob-somers">Bob Somers</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment743_876">Jul 22 '10 at 3:27</a></th></tr></thead><tbody><tr class="odd"><td>I almost completely agree with you. I did say it was desperate! –<a href="https://gamedev.stackexchange.com/users/259/tenpn">tenpn</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment772_876">Jul 22 '10 at 7:10</a></td></tr><tr class="even"><td>Wouldn't this also break short-circuiting and make branch prediction more unreliable? –<a href="https://gamedev.stackexchange.com/users/504/egon">Egon</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment810_876">Jul 22 '10 at 12:28</a></td></tr><tr class="odd"><td>If foo is 2 and bar is 1 then the code doesn't behave the same way at all. That, and not early evaluation, is the biggest downside I think. –user744 <a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment2412_876">Aug 11 '10 at 13:32</a></td></tr><tr class="even"><td>Do you know, you're absolutely right. So you need to know that either your foos and bars are all 1 or 0 (not guarenteed for booleans), or only use this for OR statements, or preferrably not do it all. :) –<a href="https://gamedev.stackexchange.com/users/259/tenpn">tenpn</a><a href="https://gamedev.stackexchange.com/questions/853/c-low-level-optimization-tips/871#comment2464_876">Aug 12 '10 at 8:04</a></td></tr></tbody></table><p></p></td></tr></tbody></table>

<table><colgroup><col style="width: 10%" /><col style="width: 89%" /></colgroup><thead><tr class="header"><th></th><th><p><strong>Keep an eye on your stack usage</strong></p><p>Everything you add to the stack is an extra push and construction when a function is called. When a large amount of stack space is required, it can sometimes be beneficial to allocate working memory ahead of time, and if the platform you're working on has fast RAM available for use - all the better!</p></th></tr></thead><tbody></tbody></table>
