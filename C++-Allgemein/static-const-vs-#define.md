# static const vs #define

Created: 2021-10-25 09:35:36 +0200

Modified: 2021-10-25 16:53:15 +0200

---


<table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th><p>Is it better to use static const vars than #define preprocessor? Or maybe it depends on the context?</p><p>What are advantages/disadvantages for each method?</p><p><a href="http://stackoverflow.com/questions/tagged/c++">c++</a></p></th></tr></thead><tbody><tr class="odd"><td><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>Scott Meyers covers this subject very nicely and thoroughly. His Item#2 in "Effective C++ Third Edition". Two special cases (1) static const is preferred within a class scope for class specific constants; (2) namespace or anonymous scope const is preferred over #define. –<a href="http://stackoverflow.com/users/12937/eric">Eric</a> <a href="http://stackoverflow.com/questions/1637332/static-const-vs-define/1637402#comment6985437_1637332">May 18 '11 at 1:48</a></th></tr></thead><tbody><tr class="odd"><td>I prefer Enums. Because it is hybrid of both. Doesn't occupy space unless you create a variable of it. If you just want to use as a constant , enum is the best option. It has type safety in C/C++11 std and also a perfect constant. #define is type unsafe , const takes space if compiler can't optimize it. –<a href="http://stackoverflow.com/users/306819/siddhusingh">siddhusingh</a> <a href="http://stackoverflow.com/questions/1637332/static-const-vs-define/1637402#comment25262359_1637332">Jul 1 '13 at 6:54</a></td></tr></tbody></table><p></p></td></tr></tbody></table>

<table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th><p>Personally, I loathe the preprocessor, so I'd always go with const.</p><p>The main advantage to a #define is that it requires no memory to store in your program, as it is really just replacing some text with a literal value. It also has the advantage that it has no type, so it can be used for any integer value without generating warnings.</p><p>Advantages of "const"s are that they can be scoped, and they can be used in situations where a pointer to an object needs to be passed.</p><p>I don't know exactly what you are getting at with the "static" part though. If you are declaring globally, I'd put it in an anonomous namespace instead of using static. For example</p><p>namespace {</p><p>unsigned const seconds_per_minute = 60;</p><p>};</p><p></p><p>int main (int argc; char *argv[]) {</p><p>...</p><p>}</p></th></tr></thead><tbody><tr class="odd"><td><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th><em>String</em> constants specifically are one of those that might benefit from being #defined, at least if they can be used as "building blocks" for bigger string constants. See my reply for an example. –<a href="http://stackoverflow.com/users/187690/ant">AnT</a> <a href="http://stackoverflow.com/questions/1637332/static-const-vs-define/1637402#comment1506661_1637367">Oct 28 '09 at 14:10</a></th></tr></thead><tbody><tr class="odd"><td>The #define advantage of not using any memory is inaccurate. The "60" at the example has to be stored somewhere, regardless if it's static const or #define. In fact, I've seen compilers where using #define caused massive (read-only) memory consumption, and static const used no un-needed memory. –<a href="http://stackoverflow.com/users/11515/gilad-naor">Gilad Naor</a> <a href="http://stackoverflow.com/questions/1637332/static-const-vs-define/1637402#comment3467285_1637367">Jul 27 '10 at 8:10</a></td></tr><tr class="even"><td>A #define is like if you had typed it in, so its definitely not coming from memory. –<a href="http://stackoverflow.com/users/433950/the-reverend">the Reverend</a> <a href="http://stackoverflow.com/questions/1637332/static-const-vs-define/1637402#comment9138004_1637367">Sep 24 '11 at 19:52</a></td></tr><tr class="odd"><td>@theReverend Are literal values somehow exempt from consuming machine resources? No, they just might use them different ways, maybe it won't appear on the stack or heap, but at some point the program is loaded into memory along with all the values compiled into it. –<a href="http://stackoverflow.com/users/17315/sqeaky">Sqeaky</a> <a href="http://stackoverflow.com/questions/1637332/static-const-vs-define/1637402#comment25331709_1637367">Jul 3 '13 at 1:07</a></td></tr><tr class="even"><td>@gilad-naor, You are right in general but small integers like 60 may actually sometimes be a sort of partial exception. Some instruction sets have the ability to encode integers or a subset of integers directly in the instruction stream. For example MIPs add immediate (<a href="http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Mips/addi.html">cs.umd.edu/class/sum2003/cmsc311/Notes/Mips/addi.html</a>). In this sort of case a #defined integer truly could be said to use no space since in the compiled binary it occupies a few spare bits in instructions which had to exist anyway. –<a href="http://stackoverflow.com/users/506073/ahcox">ahcox</a> <a href="http://stackoverflow.com/questions/1637332/static-const-vs-define/1637402#comment50130210_1637367">Jun 25 '15 at 15:23</a></td></tr></tbody></table></td></tr></tbody></table>

<table><colgroup><col style="width: 9%" /><col style="width: 90%" /></colgroup><thead><tr class="header"><th></th><th><p>Pros and cons to everything, depending on usage:</p><ul class="incremental"><li><p>enums</p></li></ul><blockquote><p></p></blockquote><ul class="incremental"><li><p>only possible for integer values</p></li><li><p>properly scoped / identifier clash issues handled nicely, particularly in C++11 enum classes where the enumerations for enum class X are disambiguated by the scope X::</p></li><li><p>strongly typed, but to a big-enough signed-or-unsigned int size over which you have no control in C++03 (though you can specify a bit field into which they should be packed if the enum is a member of struct/class/union), while C++11 defaults to int but can be explicitly set by the programmer</p></li><li><p>can't take the address - there isn't one as the enumeration values are effectively substituted inline at the points of usage</p></li><li><p>stronger usage restraints (e.g. incrementing - template &lt;typename T&gt; void f(T t) { cout &lt;&lt; ++t; } won't compile, though you can wrap an enum into a class with implicit constructor, casting operator and user-defined operators)</p></li><li><p>each constant's type taken from the enclosing enum, so template &lt;typename T&gt; void f(T) get a distinct instantiation when passed the same numeric value from different enums, all of which are distinct from any actual f(int) instantiation. Each function's object code could be identical (ignoring address offsets), but I wouldn't expect a compiler/linker to eliminate the unnecessary copies, though you could check your compiler/linker if you care.</p></li><li><p>even with typeof/decltype, can't expect numeric_limits to provide useful insight into the set of meaningful values and combinations (indeed, "legal" combinations aren't even notated in the source code, consider enum { A = 1, B = 2 } - is A|B "legal" from a program logic perspective?)</p></li><li><p>the enum's typename may appear in various places in RTTI, compiler messages etc. - possibly useful, possibly obfuscation</p></li><li><p>you can't use an enumeration without the translation unit actually seeing the value, which means enums in library APIs need the values exposed in the header, and make and other timestamp-based recompilation tools will trigger client recompilation when they're changed (bad!)</p></li><li><p>consts</p></li></ul><blockquote><p></p></blockquote><ul class="incremental"><li><p>properly scoped / identifier clash issues handled nicely</p></li><li><p>strong, single, user-specified type</p></li></ul><blockquote><p></p></blockquote><ul class="incremental"><li><p>you might try to "type" a #define ala #define S std::string("abc"), but the constant avoids repeated construction of distinct temporaries at each point of use</p></li><li><p>One Definition Rule complications</p></li><li><p>can take address, create const references to them etc.</p></li><li><p>most similar to a non-const value, which minimises work and impact if switching between the two</p></li><li><p>value can be placed inside the implementation file, allowing a localised recompile and just client links to pick up the change</p></li><li><p>defines</p></li></ul><blockquote><p></p></blockquote><ul class="incremental"><li><p>"global" scope / more prone to conflicting usages, which can produce hard-to-resolve compilation issues and unexpected run-time results rather than sane error messages; mitigating this requires:</p></li></ul><blockquote><p></p></blockquote><ul class="incremental"><li><p>long, obscure and/or centrally coordinated identifiers, and access to them can't benefit from implicitly matching used/current/Koenig-looked-up namespace, namespace aliases etc.</p></li><li><p>while the trumping best-practice allows template parameter identifiers to be single-character uppercase letters (possibly followed by a number), other use of identifiers without lowercase letters is conventionally reserved for and expected of preprocessor defines (outside the OS and C/C++ library headers). This is important for enterprise scale preprocessor usage to remain manageable. 3rd party libraries can be expected to comply. Observing this implies migration of existing consts or enums to/from defines involves a change in capitalisation, and hence requires edits to client source code rather than a "simple" recompile. (Personally, I capitalise the first letter of enumerations but not consts, so I'd be hit migrating between those two too - maybe time to rethink that.)</p></li><li><p>more compile-time operations possible: string literal concatenation, stringification (taking size thereof), concatenation into identifiers</p></li></ul><blockquote><p></p></blockquote><ul class="incremental"><li><p>downside is that given #define X "x" and some client usage ala "pre" X "post", if you want or need to make X a runtime-changeable variable rather than a constant you force edits to client code (rather than just recompilation), whereas that transition is easier from a const char* or const std::string given they already force the user to incorporate concatenation operations (e.g. "pre" + X + "post" for string)</p></li><li><p>can't use sizeof directly on a defined numeric literal</p></li><li><p>untyped (GCC doesn't warn if compared to unsigned)</p></li><li><p>some compiler/linker/debugger chains may not present the identifier, so you'll be reduced to looking at "magic numbers" (strings, whatever...)</p></li><li><p>can't take the address</p></li><li><p>the substituted value need not be legal (or discrete) in the context where the #define is created, as it's evaluated at each point of use, so you can reference not-yet-declared objects, depend on "implementation" that needn't be pre-included, create "constants" such as { 1, 2 } that can be used to initialise arrays, or #define MICROSECONDS *1E-6 etc. (<em>definitely</em> not recommending this!)</p></li><li><p>some special things like __FILE__ and __LINE__ can be incorporated into the macro substitution</p></li><li><p>you can test for existence and value in #if statements for conditionally including code (more powerful than a post-preprocessing "if" as the code need not be compilable if not selected by the preprocessor), use #undef-ine, redefine etc.</p></li><li><p>substituted text has to be exposed:</p></li></ul><blockquote><p></p></blockquote><ul class="incremental"><li><p>in the translation unit it's used by, which means macros in libraries for client use must be in the header, so make and other timestamp-based recompilation tools will trigger client recompilation when they're changed (bad!)</p></li><li><p>or on the command line, where even more care is needed to make sure client code is recompiled (e.g. the Makefile or script supplying the definition should be listed as a dependency)</p></li></ul><p>As a general rule, I use consts and consider them the most professional option for general usage (though the others have a simplicity appealing to this old lazy programmer).</p><p></p></th></tr></thead><tbody><tr class="odd"><td><p></p><p></p></td><td><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>+1: Appreciate your summarization –<a href="http://stackoverflow.com/users/418110/chubsdad">Chubsdad</a> <a href="http://stackoverflow.com/questions/1637332/static-const-vs-define/1637402#comment4073810_3835772">Oct 1 '10 at 1:09</a></th></tr></thead><tbody><tr class="odd"><td>Awesome answer. One small nit : i sometimes use local enums that are not in headers at all just for clarity of the code, like in small state machines and such. So they don't have to be in headers, at all times. –<a href="http://stackoverflow.com/users/295231/kert">kert</a> <a href="http://stackoverflow.com/questions/1637332/static-const-vs-define/1637402#comment37218658_3835772">Jun 9 '14 at 15:46</a></td></tr><tr class="even"><td>@kert: solid point... have edited accordingly. Thanks. –<a href="http://stackoverflow.com/users/410767/tony-d">Tony D</a> <a href="http://stackoverflow.com/questions/1637332/static-const-vs-define/1637402#comment37233552_3835772">Jun 10 '14 at 1:28</a></td></tr></tbody></table><p></p></td></tr></tbody></table>

<table><colgroup><col style="width: 10%" /><col style="width: 89%" /></colgroup><thead><tr class="header"><th></th><th><p>If this is a C++ question and it mentions #define as an alternative, then it is about "global" (i.e. file-scope) constants, not about class members. When it comes to such constants in C++ static const is redundant. In C++ const have internal linkage by default and there's no point in declaring them static. So it is really about const vs. #define.</p><p>And, finally, in C++ const is preferable. At least because such constants are typed and scoped. There are simply no reasons to prefer #define over const, aside from few exceptions.</p><p>String constants, BTW, are one example of such an exception. With #defined string constants one can use compile-time concatenation feature of C/C++ compilers, as in</p><p>#define OUT_NAME "output"</p><p>#define LOG_EXT ".log"</p><p>#define TEXT_EXT ".txt"</p><p></p><p>const char *const log_file_name = OUT_NAME LOG_EXT;</p><p>const char *const text_file_name = OUT_NAME TEXT_EXT;</p><p>P.S. Again, just in case, when someone mentions static const as an alternative to #define, it usually means that they are talking about C, not about C++. I wonder whether this question is tagged properly...</p><p></p></th></tr></thead><tbody></tbody></table>

<table><colgroup><col style="width: 10%" /><col style="width: 89%" /></colgroup><thead><tr class="header"><th></th><th><p>Using a static const is like using any other const variables in your code. This means you can trace wherever the information comes from, as opposed to a #define that will simply be replaced in the code in the pre-compilation process.</p><p>You might want to take a look at the C++ FAQ Lite for this question: <a href="http://www.parashift.com/c++-faq-lite/newbie.html#faq-29.7">http://www.parashift.com/c++-faq-lite/newbie.html#faq-29.7</a></p><p></p></th></tr></thead><tbody></tbody></table>

<table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th><ul class="incremental"><li><p>A static const is typed (it has a type) and can be checked by the compiler for validity, redefinition etc.</p></li><li><p>a #define can be redifined undefined whatever.</p></li></ul><blockquote><p>Usually you should prefer static consts. It has no disadvantage. The prprocessor should mainly be used for conditional compilation (and sometimes for really dirty trics maybe).</p></blockquote></th></tr></thead><tbody></tbody></table>



Please see here: [static const vs define](http://cboard.cprogramming.com/cplusplus-programming/96595-static-const-vs-sharpdefine.html)

usually a const declaration (notice it doesn't need to be static) is the way to go

Defining constants by using preprocessor directive #define is not recommended to apply not only in C++, but also in C. These constants will not have the type. Even in C was proposed to use const for constants.

<table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th><p>If you are defining a constant to be shared among all the instances of the class, use static const. If the constant is specific to each instance, just use const (but note that all constructors of the class must initialize this const member variable in the initialization list).</p><p></p></th></tr></thead><tbody></tbody></table>
